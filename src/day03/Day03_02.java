package day03;

public class Day03_02 {
	public static void main(String[] args) {
		//논리 연산자와 비트 연산자.
		int i = 1;
		int j = i++; //후위연산자이기 때문에 j = 1 저장 후 i=2;
		
		//인트 아이에 1이 저장 되었다.
		//인트 제이가 선언되고, 선언된 제이에 아이가 저장되었다.
		//그 후 아이에 ++이게 붙었으니 1이 추가가 된다.
		//그래서? 아이는 2가 됐다.
		// 그러므로 i= 2, j=1;
		
		System.out.println("");
		if ((i > ++j) && (i++ == j)) {
			//if문
			//아이와 제이가 있다. 그 둘을 꺽쇄로 비교한다.
			//아이가 제이보다 크면 트루가 되는 식이다.
			//아이 값은 몇이냐? 아는 2였다!
			//제이 값은 몇이냐! 제이는 1이였다.
			//근데 제이 앞에 ++가 붙어있어서 이걸 비교하기전에
			//제이한테 1을 더해줘야 한다. 고로 제이는 2
			//그래서 아이는 제이보다 크다는 이 식은 틀렸다.
			//i> ++j 는 틀렸다. false
			//&&는 앞에께 틀렸으면 뒤에껄 실행하지 않는다.
			//하지만 뒤에것도 한번 분석이나 해봐야겠다.
			//아이와 제이 가 있다.
			//두개를 감싸고 있ㄴ는 부호들은 ++와 ==이 있다.
			//두개가 같은지 비교를 하는 부호 ==
			//아이의 뒤에 ++가 붙었으니 비교 후 아이에 1이 추가된다.
			//제이에는 2가 저장되어있었네
			//아이에는 2가 저장되어있었네? 근데 이 비교가 끝나면 ++로 인해
			//아이에 1이 추가 된다.
			//일단 비교
			//제이는 2고 아이는 아직은 2니깐 두개는 같다.
			//고로 i++ == j 는 옳다. true 
			//이후에 i++니깐 아이에 1이 더해진다. 아까 아이값이 몇이였지?
			//위에 보니깐 2였네? 2 + 1 
			//고로 아이는 3 제이는 2
			//아참 &&이게 있어서 앞에께 false였으니
			//뒤의 식은 수행이 되면 안되는구나
			//그럼 i는 몇이지? j는 몇이지?
			
			
			
			// (2>2)&&(2==2) 곧 false&&true = false
			// 컴퓨터에서 바라는 값은 항상 true
			/*
			 * &&에서 앞의 논리가 false일 경우 뒤의 논리는 수행되지 않는다.
			 * 그렇기 때문에  뒤의 (i++==j)는 수행되지 않는다. 
			 * ||의 경우는 앞의 값이 true일 경우 
			 * 뒤의 논리를 굳이 수행하지 않는다.
			 * 
			 * 그렇기 때문에 제대로 된 값을 수행하기 위해서는
			 * 비트연산자 &  |  ^ 를! 사용해야한다.
			 */
			i += j;
		}

		System.out.println("i=" + i + "/ j=" + j);

	}
}
